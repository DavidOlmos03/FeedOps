{
  "name": "GitHub API Monitor",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "*/5 * * * *"
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM feed_sources WHERE source_type = 'github_api' AND enabled = true"
      },
      "id": "get-github-sources",
      "name": "Get GitHub API Sources",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [450, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Split each source into multiple items - one per event type\nconst source = $input.item.json;\nconst config = source.config || {};\nconst eventTypes = config.event_types || ['push', 'issues'];\n\nconst lastCheck = source.last_check \n  ? new Date(source.last_check).toISOString()\n  : new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();\n\n// Create one item per event type\nconst items = eventTypes.map(eventType => {\n  let endpoint, apiPath;\n  \n  if (eventType === 'push') {\n    // Use events endpoint to get push events from ALL branches\n    endpoint = 'events';\n    apiPath = `/repos/${source.source_identifier}/events`;\n  } else if (eventType === 'issues') {\n    endpoint = 'issues';\n    apiPath = `/repos/${source.source_identifier}/issues`;\n  }\n  \n  return {\n    source_id: source.id,\n    repository: source.source_identifier,\n    event_type: eventType,\n    endpoint: endpoint,\n    api_path: apiPath,\n    last_check: lastCheck,\n    config: config\n  };\n});\n\nreturn items;"
      },
      "id": "split-by-event-type",
      "name": "Split by Event Type",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "functionCode": "// Build request parameters based on event type\nconst data = $json;\nconst queryParams = {\n  per_page: 100  // Increased to catch more commits\n};\n\n// Add parameters specific to each endpoint\nif (data.event_type === 'push') {\n  // For commits endpoint - don't use 'since' as it filters by author date\n  // We'll filter by commit date manually after fetching\n  // No additional params needed - defaults to newest first\n} else if (data.event_type === 'issues') {\n  // For issues endpoint\n  queryParams.since = data.last_check;\n  queryParams.state = 'all';\n  queryParams.sort = 'updated';\n  queryParams.direction = 'desc';\n}\n\nreturn {\n  ...data,\n  query_params: queryParams\n};"
      },
      "id": "prepare-api-params",
      "name": "Prepare API Parameters",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [750, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://api.github.com{{$json.api_path}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "X-GitHub-Api-Version",
              "value": "2022-11-28"
            }
          ]
        },
        "sendQuery": true,
        "specifyQueryString": true,
        "queryString": "={{Object.entries($json.query_params).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&')}}",
        "options": {}
      },
      "id": "fetch-github-api",
      "name": "Fetch GitHub API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [950, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "4",
          "name": "GitHub API Token"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Combine ALL API responses with context from Prepare API Parameters\n// Collect all items from the HTTP Request and attach context to each\n\nconst allApiItems = $input.all();\nconst prepareData = $('Prepare API Parameters').item.json;\n\n// Return all API response items as an array with context attached\nreturn {\n  api_response: allApiItems.map(item => item.json),\n  source_id: prepareData.source_id,\n  repository: prepareData.repository,\n  event_type: prepareData.event_type,\n  last_check: prepareData.last_check,\n  config: prepareData.config\n};"
      },
      "id": "merge-context",
      "name": "Merge Context",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "functionCode": "// Split events array into individual items\nconst data = $input.item.json;\n\nif (!data.api_response || !Array.isArray(data.api_response)) {\n  return [];\n}\n\n// Map each event with context\nreturn data.api_response.map(event => ({\n  ...event,\n  _context: {\n    source_id: data.source_id,\n    repository: data.repository,\n    event_type: data.event_type,\n    last_check: data.last_check,\n    config: data.config || {}\n  }\n}));"
      },
      "id": "split-events",
      "name": "Split Events",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1150, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.type}}",
              "operation": "equal",
              "value2": "PushEvent"
            }
          ],
          "dateTime": [
            {
              "value1": "={{$json.created_at}}",
              "operation": "after",
              "value2": "={{$json._context.last_check}}"
            }
          ]
        }
      },
      "id": "filter-push-events",
      "name": "Filter Push Events",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1350, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://api.github.com/repos/{{$json._context.repository}}/commits/{{$json.payload.head}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "X-GitHub-Api-Version",
              "value": "2022-11-28"
            }
          ]
        },
        "options": {}
      },
      "id": "get-commit-details",
      "name": "Get Commit Details",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1550, 200],
      "credentials": {
        "httpHeaderAuth": {
          "id": "4",
          "name": "GitHub API Token"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "functionCode": "// Combine push event with commit details\nconst commitDetails = $json;\nconst pushEvent = $node['Filter Push Events'].json;\n\n// Check if commit details fetch failed\nif (commitDetails.error) {\n  console.error('Failed to fetch commit details:', commitDetails.error);\n  // Create a basic commit object with available info\n  const payload = pushEvent.payload || {};\n  return {\n    event: pushEvent,\n    commit: {\n      sha: payload.head,\n      html_url: `https://github.com/${pushEvent._context.repository}/commit/${payload.head}`,\n      commit: {\n        message: `Commit ${payload.head?.substring(0, 7) || 'unknown'}`,\n        author: {\n          name: pushEvent.actor?.login || 'Unknown'\n        }\n      }\n    },\n    _context: pushEvent._context\n  };\n}\n\nreturn {\n  event: pushEvent,\n  commit: commitDetails,\n  _context: pushEvent._context\n};"
      },
      "id": "combine-commit-data",
      "name": "Combine Commit Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1750, 200]
    },
    {
      "parameters": {
        "functionCode": "// Normalize enriched GitHub event to standard schema\nconst crypto = require('crypto');\nconst data = $input.item.json;\n\nconst event = data.event;\nconst commit = data.commit;\nconst context = data._context;\n\nconst config = context.config || {};\nconst payload = event.payload || {};\n\n// Extract branch from ref (e.g., \"refs/heads/main\" -> \"main\")\nconst ref = payload.ref || '';\nconst branch = ref.replace('refs/heads/', '');\n\n// Get commit message\nconst commitMessage = commit.commit?.message || '';\nconst firstLine = commitMessage.split('\\n')[0].trim();\nconst formattedDescription = firstLine ? `ðŸ“„ ${firstLine}` : '';\n\n// Apply keyword filter if configured\nif (config.keywords) {\n  const keywords = config.keywords.toLowerCase().split(',');\n  const searchText = (firstLine + ' ' + commitMessage).toLowerCase();\n  const hasKeyword = keywords.some(kw => searchText.includes(kw.trim()));\n  if (!hasKeyword) {\n    return null; // Skip this commit\n  }\n}\n\nconst normalizedItem = {\n  source: 'github',\n  source_id: context.source_id,\n  event_type: 'push',\n  timestamp: event.created_at || new Date().toISOString(),\n  repository: context.repository,\n  url: commit.html_url || `https://github.com/${context.repository}/commit/${commit.sha}`,\n  title: `New commit to ${context.repository}`,\n  description: formattedDescription,\n  author: commit.commit?.author?.name || event.actor?.login || 'Unknown',\n  item_id: `github_polling_push_${context.source_id}_${commit.sha}`,\n  metadata: {\n    sha: commit.sha,\n    branch: branch,\n    full_message: commitMessage,\n    committer: commit.commit?.author?.name || 'Unknown',\n    event_id: event.id\n  }\n};\n\nnormalizedItem.content_hash = crypto.createHash('sha256')\n  .update(JSON.stringify({\n    sha: commit.sha,\n    message: commitMessage,\n    branch: branch,\n    timestamp: event.created_at\n  }))\n  .digest('hex');\n\nreturn normalizedItem;"
      },
      "id": "normalize-data",
      "name": "Normalize Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1950, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT item_id FROM notifications_history WHERE item_id = $1 LIMIT 1",
        "options": {
          "queryParameters": {
            "parameters": [
              {
                "name": "1",
                "value": "={{$json.item_id}}"
              }
            ]
          }
        }
      },
      "id": "check-duplicate",
      "name": "Check Duplicate",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [2350, 200],
      "alwaysOutputData": true,
      "continueOnFail": false
    },
    {
      "parameters": {
        "functionCode": "// Pass through normalized data with item_id for checking\nconst normalized = $json;\nreturn {\n  ...normalized,\n  _check_item_id: normalized.item_id\n};"
      },
      "id": "prepare-for-duplicate-check",
      "name": "Prepare for Duplicate Check",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2150, 200]
    },
    {
      "parameters": {
        "functionCode": "// Combine Check Duplicate result with normalized data\nconst checkResult = $json;\nconst normalizedData = $node['Prepare for Duplicate Check'].json;\n\n// Check if duplicate exists\nconst isDuplicate = Array.isArray(checkResult) && checkResult.length > 0;\n\n// Return normalized data with duplicate flag\nreturn {\n  ...normalizedData,\n  _is_duplicate: isDuplicate,\n  _duplicate_count: Array.isArray(checkResult) ? checkResult.length : 0\n};"
      },
      "id": "combine-check-result",
      "name": "Combine Check Result",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2550, 200]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._is_duplicate}}",
              "operation": "notEqual",
              "value2": true
            }
          ]
        }
      },
      "id": "is-new",
      "name": "Is New?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2750, 200]
    },
    {
      "parameters": {
        "functionCode": "// Pass normalized event data to Telegram Dispatcher\nconst data = $json;\n\n// Remove internal flags added during processing\nconst { _is_duplicate, _duplicate_count, _check_item_id, ...cleanData } = data;\n\nreturn cleanData;"
      },
      "id": "prepare-telegram-data",
      "name": "Prepare Telegram Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2950, 100]
    },
    {
      "parameters": {
        "mode": "list",
        "workflowId": "",
        "source": "database"
      },
      "id": "send-to-telegram",
      "name": "Send to Telegram",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [3150, 100]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO notifications_history (source_id, item_id, item_hash, title, url, metadata) VALUES ($1, $2, $3, $4, $5, $6)",
        "options": {
          "queryParameters": {
            "parameters": [
              {
                "name": "1",
                "value": "={{$json.source_id}}"
              },
              {
                "name": "2",
                "value": "={{$json.item_id}}"
              },
              {
                "name": "3",
                "value": "={{$json.content_hash}}"
              },
              {
                "name": "4",
                "value": "={{$json.title}}"
              },
              {
                "name": "5",
                "value": "={{$json.url}}"
              },
              {
                "name": "6",
                "value": "={{JSON.stringify($json.metadata)}}"
              }
            ]
          }
        }
      },
      "id": "log-notification",
      "name": "Log Notification",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [2950, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE feed_sources SET last_check = NOW(), error_count = 0 WHERE id = $1",
        "options": {
          "queryParameters": {
            "parameters": [
              {
                "name": "1",
                "value": "={{$json.source_id}}"
              }
            ]
          }
        }
      },
      "id": "update-source-status",
      "name": "Update Source Status",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [3350, 200]
    },
    {
      "parameters": {
        "functionCode": "// Error handler - log error and pass source_id for update\nconst sourceData = $node['Prepare API Parameters'].json;\nconst errorMessage = $json.error?.message || 'Unknown error';\nconst statusCode = $json.error?.statusCode;\n\nconsole.error(`GitHub API fetch error for ${sourceData.repository}:`, {\n  message: errorMessage,\n  statusCode: statusCode,\n  event_type: sourceData.event_type\n});\n\nreturn { \n  source_id: sourceData.source_id, \n  error: errorMessage,\n  status_code: statusCode\n};"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 500]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE feed_sources SET error_count = error_count + 1, last_check = NOW() WHERE id = $1",
        "options": {
          "queryParameters": {
            "parameters": [
              {
                "name": "1",
                "value": "={{$json.source_id}}"
              }
            ]
          }
        }
      },
      "id": "update-error-count",
      "name": "Update Error Count",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1250, 500]
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get GitHub API Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get GitHub API Sources": {
      "main": [
        [
          {
            "node": "Split by Event Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split by Event Type": {
      "main": [
        [
          {
            "node": "Prepare API Parameters",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare API Parameters": {
      "main": [
        [
          {
            "node": "Fetch GitHub API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch GitHub API": {
      "main": [
        [
          {
            "node": "Merge Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Context": {
      "main": [
        [
          {
            "node": "Split Events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Events": {
      "main": [
        [
          {
            "node": "Filter Push Events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Push Events": {
      "main": [
        [
          {
            "node": "Get Commit Details",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Commit Details": {
      "main": [
        [
          {
            "node": "Combine Commit Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Commit Data": {
      "main": [
        [
          {
            "node": "Normalize Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Data": {
      "main": [
        [
          {
            "node": "Prepare for Duplicate Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Duplicate Check": {
      "main": [
        [
          {
            "node": "Check Duplicate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Duplicate": {
      "main": [
        [
          {
            "node": "Combine Check Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Check Result": {
      "main": [
        [
          {
            "node": "Is New?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is New?": {
      "main": [
        [
          {
            "node": "Prepare Telegram Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "Log Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Telegram Data": {
      "main": [
        [
          {
            "node": "Send to Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Telegram": {
      "main": [
        [
          {
            "node": "Update Source Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Notification": {
      "main": [
        [
          {
            "node": "Update Source Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Update Error Count",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "saveExecutionProgress": true
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1"
}
