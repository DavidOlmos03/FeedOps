{
  "name": "GitHub API Monitor",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "*/5 * * * *"
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM feed_sources WHERE source_type = 'github_api' AND enabled = true"
      },
      "id": "get-github-sources",
      "name": "Get GitHub API Sources",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [450, 300],
      "credentials": {
        "postgres": {
          "id": "1",
          "name": "PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Split each source into multiple items - one per event type\nconst source = $input.item.json;\nconst config = source.config || {};\nconst eventTypes = config.event_types || ['push', 'issues'];\n\nconst lastCheck = source.last_check \n  ? new Date(source.last_check).toISOString()\n  : new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(); // Default: last 24 hours\n\n// Create one item per event type\nconst items = eventTypes.map(eventType => {\n  let endpoint, apiPath;\n  \n  if (eventType === 'push') {\n    endpoint = 'commits';\n    apiPath = `/repos/${source.source_identifier}/commits`;\n  } else if (eventType === 'issues') {\n    endpoint = 'issues';\n    apiPath = `/repos/${source.source_identifier}/issues`;\n  }\n  \n  return {\n    source_id: source.id,\n    repository: source.source_identifier,\n    event_type: eventType,\n    endpoint: endpoint,\n    api_path: apiPath,\n    last_check: lastCheck,\n    config: config\n  };\n});\n\nreturn items;"
      },
      "id": "split-by-event-type",
      "name": "Split by Event Type",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [650, 300]
    },
    {
      "parameters": {
        "functionCode": "// Build request parameters based on event type\nconst data = $json;\nconst queryParams = {\n  per_page: 100  // Increased to catch more commits\n};\n\n// Add parameters specific to each endpoint\nif (data.event_type === 'push') {\n  // For commits endpoint - don't use 'since' as it filters by author date\n  // We'll filter by commit date manually after fetching\n  // No additional params needed - defaults to newest first\n} else if (data.event_type === 'issues') {\n  // For issues endpoint\n  queryParams.since = data.last_check;\n  queryParams.state = 'all';\n  queryParams.sort = 'updated';\n  queryParams.direction = 'desc';\n}\n\nreturn {\n  ...data,\n  query_params: queryParams\n};"
      },
      "id": "prepare-api-params",
      "name": "Prepare API Parameters",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [750, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://api.github.com{{$json.api_path}}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/vnd.github+json"
            },
            {
              "name": "X-GitHub-Api-Version",
              "value": "2022-11-28"
            }
          ]
        },
        "sendQuery": true,
        "specifyQueryString": true,
        "queryString": "={{Object.entries($json.query_params).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&')}}",
        "options": {}
      },
      "id": "fetch-github-api",
      "name": "Fetch GitHub API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [950, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "4",
          "name": "GitHub API Token"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Combine ALL API responses with context from Prepare API Parameters\n// Collect all items from the HTTP Request and attach context to each\n\nconst allApiItems = $input.all();\nconst prepareData = $('Prepare API Parameters').item.json;\n\n// Return all API response items as an array with context attached\nreturn {\n  api_response: allApiItems.map(item => item.json),\n  source_id: prepareData.source_id,\n  repository: prepareData.repository,\n  event_type: prepareData.event_type,\n  last_check: prepareData.last_check,\n  config: prepareData.config\n};"
      },
      "id": "merge-context",
      "name": "Merge Context",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "functionCode": "// Normalize GitHub API response to standard schema\nconst crypto = require('crypto');\n\n// Get the combined data (API response + context)\nconst data = $input.item.json;\n\n// Validate data structure\nif (!data.api_response) {\n  throw new Error(`Missing api_response. Data keys: ${Object.keys(data).join(', ')}`);\n}\n\nconst apiResponse = data.api_response;\nconst sourceData = {\n  source_id: data.source_id,\n  repository: data.repository,\n  event_type: data.event_type,\n  last_check: data.last_check,\n  config: data.config || {}\n};\n\n// Validate API response is an array\nif (!Array.isArray(apiResponse)) {\n  throw new Error(`API response is not an array. Type: ${typeof apiResponse}, Value: ${JSON.stringify(apiResponse).substring(0, 200)}`);\n}\n\nif (apiResponse.length === 0) {\n  // No new commits/issues - return empty array\n  return [];\n}\n\nconst eventType = sourceData.event_type;\nconst config = sourceData.config;\nconst normalized = [];\n\nfor (const apiItem of apiResponse) {\n  if (!apiItem || typeof apiItem !== 'object') continue;\n  \n  let normalizedItem;\n  \n  if (eventType === 'push') {\n    // Validate commit data\n    if (!apiItem.sha || !apiItem.commit) continue;\n    \n    const commitMessage = apiItem.commit?.message || '';\n    const firstLine = commitMessage.split('\\n')[0].trim();\n    const formattedDescription = firstLine ? `ðŸ“„ ${firstLine}` : '';\n    \n    normalizedItem = {\n      source: 'github',\n      source_id: sourceData.source_id,\n      event_type: 'push',\n      timestamp: apiItem.commit?.committer?.date || apiItem.commit?.author?.date || new Date().toISOString(),\n      repository: sourceData.repository,\n      url: apiItem.html_url || apiItem.url,\n      title: `New commit to ${sourceData.repository}`,\n      description: formattedDescription,\n      author: apiItem.commit?.author?.name || apiItem.author?.login || 'Unknown',\n      item_id: `github_polling_push_${sourceData.source_id}_${apiItem.sha}`,\n      metadata: {\n        sha: apiItem.sha,\n        full_message: commitMessage,\n        committer: apiItem.commit?.committer?.name || 'Unknown'\n      }\n    };\n    \n    normalizedItem.content_hash = crypto.createHash('sha256')\n      .update(JSON.stringify({\n        sha: apiItem.sha,\n        message: commitMessage,\n        date: apiItem.commit?.committer?.date || apiItem.commit?.author?.date\n      }))\n      .digest('hex');\n      \n  } else if (eventType === 'issues') {\n    // Validate issue data\n    if (!apiItem.number) continue;\n    if (apiItem.pull_request && !config.include_pull_requests) continue;\n    \n    normalizedItem = {\n      source: 'github',\n      source_id: sourceData.source_id,\n      event_type: 'issues',\n      timestamp: apiItem.updated_at || apiItem.created_at || new Date().toISOString(),\n      repository: sourceData.repository,\n      url: apiItem.html_url || apiItem.url,\n      title: `Issue #${apiItem.number}: ${apiItem.title || 'No title'}`,\n      description: (apiItem.body || '').substring(0, 500),\n      author: apiItem.user?.login || 'Unknown',\n      item_id: `github_polling_issues_${sourceData.source_id}_${apiItem.id}`,\n      metadata: {\n        number: apiItem.number,\n        state: apiItem.state,\n        labels: (apiItem.labels || []).map(l => l.name),\n        comments: apiItem.comments || 0,\n        is_pull_request: !!apiItem.pull_request\n      }\n    };\n    \n    normalizedItem.content_hash = crypto.createHash('sha256')\n      .update(JSON.stringify({\n        id: apiItem.id,\n        number: apiItem.number,\n        title: apiItem.title,\n        state: apiItem.state,\n        updated_at: apiItem.updated_at\n      }))\n      .digest('hex');\n  }\n  \n  if (normalizedItem) {\n    normalized.push(normalizedItem);\n  }\n}\n\nreturn normalized;"
      },
      "id": "normalize-data",
      "name": "Normalize Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1150, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT item_id FROM notifications_history WHERE item_id = $1 LIMIT 1",
        "options": {
          "queryParameters": {
            "parameters": [
              {
                "name": "1",
                "value": "={{$json.item_id}}"
              }
            ]
          }
        }
      },
      "id": "check-duplicate",
      "name": "Check Duplicate",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1250, 300],
      "alwaysOutputData": true,
      "continueOnFail": false
    },
    {
      "parameters": {
        "functionCode": "// Pass through normalized data with item_id for checking\nconst normalized = $json;\nreturn {\n  ...normalized,\n  _check_item_id: normalized.item_id\n};"
      },
      "id": "prepare-for-duplicate-check",
      "name": "Prepare for Duplicate Check",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1150, 300]
    },
    {
      "parameters": {
        "functionCode": "// Combine Check Duplicate result with normalized data\nconst checkResult = $json;\nconst normalizedData = $node['Prepare for Duplicate Check'].json;\n\n// Check if duplicate exists\nconst isDuplicate = Array.isArray(checkResult) && checkResult.length > 0;\n\n// Return normalized data with duplicate flag\nreturn {\n  ...normalizedData,\n  _is_duplicate: isDuplicate,\n  _duplicate_count: Array.isArray(checkResult) ? checkResult.length : 0\n};"
      },
      "id": "combine-check-result",
      "name": "Combine Check Result",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1350, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._is_duplicate}}",
              "operation": "notEqual",
              "value2": true
            }
          ]
        }
      },
      "id": "is-new",
      "name": "Is New?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1550, 300]
    },
    {
      "parameters": {
        "functionCode": "// Pass normalized event data to Telegram Dispatcher\nconst data = $json;\n\n// Remove internal flags added during processing\nconst { _is_duplicate, _duplicate_count, _check_item_id, ...cleanData } = data;\n\nreturn cleanData;"
      },
      "id": "prepare-telegram-data",
      "name": "Prepare Telegram Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1650, 200]
    },
    {
      "parameters": {
        "mode": "list",
        "workflowId": "",
        "source": "database"
      },
      "id": "send-to-telegram",
      "name": "Send to Telegram",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [1850, 200]
    },
    {
      "parameters": {
        "operation": "insert",
        "table": "notifications_history",
        "columns": "source_id,item_id,item_hash,title,url,metadata",
        "options": {
          "queryParameters": {
            "parameters": [
              {
                "name": "1",
                "value": "={{$json.source_id}}"
              },
              {
                "name": "2",
                "value": "={{$json.item_id}}"
              },
              {
                "name": "3",
                "value": "={{$json.content_hash}}"
              },
              {
                "name": "4",
                "value": "={{$json.title}}"
              },
              {
                "name": "5",
                "value": "={{$json.url}}"
              },
              {
                "name": "6",
                "value": "={{JSON.stringify($json.metadata)}}"
              }
            ]
          }
        }
      },
      "id": "log-notification",
      "name": "Log Notification",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1650, 400]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE feed_sources SET last_check = NOW(), error_count = 0 WHERE id = $1",
        "options": {
          "queryParameters": {
            "parameters": [
              {
                "name": "1",
                "value": "={{$json.source_id}}"
              }
            ]
          }
        }
      },
      "id": "update-source-status",
      "name": "Update Source Status",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "functionCode": "// Error handler - log error and pass source_id for update\nconst sourceData = $node['Prepare API Parameters'].json;\nconst errorMessage = $json.error?.message || 'Unknown error';\nconst statusCode = $json.error?.statusCode;\n\nconsole.error(`GitHub API fetch error for ${sourceData.repository}:`, {\n  message: errorMessage,\n  statusCode: statusCode,\n  event_type: sourceData.event_type\n});\n\nreturn { \n  source_id: sourceData.source_id, \n  error: errorMessage,\n  status_code: statusCode\n};"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 500]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE feed_sources SET error_count = error_count + 1, last_check = NOW() WHERE id = $1",
        "options": {
          "queryParameters": {
            "parameters": [
              {
                "name": "1",
                "value": "={{$json.source_id}}"
              }
            ]
          }
        }
      },
      "id": "update-error-count",
      "name": "Update Error Count",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 1,
      "position": [1250, 500]
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Get GitHub API Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get GitHub API Sources": {
      "main": [
        [
          {
            "node": "Split by Event Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split by Event Type": {
      "main": [
        [
          {
            "node": "Prepare API Parameters",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare API Parameters": {
      "main": [
        [
          {
            "node": "Fetch GitHub API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch GitHub API": {
      "main": [
        [
          {
            "node": "Merge Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Context": {
      "main": [
        [
          {
            "node": "Normalize Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Data": {
      "main": [
        [
          {
            "node": "Prepare for Duplicate Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Duplicate Check": {
      "main": [
        [
          {
            "node": "Check Duplicate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Duplicate": {
      "main": [
        [
          {
            "node": "Combine Check Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Check Result": {
      "main": [
        [
          {
            "node": "Is New?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is New?": {
      "main": [
        [
          {
            "node": "Prepare Telegram Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "Log Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Telegram Data": {
      "main": [
        [
          {
            "node": "Send to Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Telegram": {
      "main": [
        [
          {
            "node": "Update Source Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Notification": {
      "main": [
        [
          {
            "node": "Update Source Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Update Error Count",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "saveExecutionProgress": true
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1"
}
